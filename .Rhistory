##check for valid calls
outcomecall <- paste(outcomecall,"+",sep="")
if (!any(agrep(outcomecall,colnames(data),ignore.case=TRUE))) {
stop('invalid outcome')
}
if (!any(data$State==statecall)) {
stop('invalid state')
}
##assign values for best and worst
if (num=="best") {
num<-1
}
#what to do for worst
##filter by state
statedata <- subset(data,State==statecall)
##determine which column corresponds to outcome of interest
outcomeindex <- min(agrep(outcomecall,colnames(data),ignore.case=TRUE))
##build answermatrix and then clean out NAs
answermatrix <- statedata[,c(2,outcomeindex)]
answermatrix[,2] <- as.numeric(as.character(answermatrix[,2]))
gooddata <- complete.cases(answermatrix)
answermatrix <- answermatrix[gooddata,]
print(answermatrix)
##find the hospital with the lowest score
sorted<-order(answermatrix[,1])
print (sorted)
}
rankhospital("TX","heart failure",4)
rankhospital <- function (statecall,outcomecall,num="best"){
##read in the data
path <- "C:\\Users\\Rich\\Documents\\Github\\FirstRepo\\outcome-of-care-measures.csv"
data <- read.csv(path,stringsAsFactors=FALSE,na.strings="Not Available+")
##check for valid calls
outcomecall <- paste(outcomecall,"+",sep="")
if (!any(agrep(outcomecall,colnames(data),ignore.case=TRUE))) {
stop('invalid outcome')
}
if (!any(data$State==statecall)) {
stop('invalid state')
}
##assign values for best and worst
if (num=="best") {
num<-1
}
#what to do for worst
##filter by state
statedata <- subset(data,State==statecall)
##determine which column corresponds to outcome of interest
outcomeindex <- min(agrep(outcomecall,colnames(data),ignore.case=TRUE))
##build answermatrix and then clean out NAs
answermatrix <- statedata[,c(2,outcomeindex)]
answermatrix[,2] <- as.numeric(as.character(answermatrix[,2]))
gooddata <- complete.cases(answermatrix)
answermatrix <- answermatrix[gooddata,]
print(answermatrix)
##find the hospital with the lowest score
sorted<-which.min(answermatrix[,1])
print (sorted)
}
rankhospital("TX","heart failure",4)
rankhospital <- function (statecall,outcomecall,num="best"){
##read in the data
path <- "C:\\Users\\Rich\\Documents\\Github\\FirstRepo\\outcome-of-care-measures.csv"
data <- read.csv(path,stringsAsFactors=FALSE,na.strings="Not Available+")
##check for valid calls
outcomecall <- paste(outcomecall,"+",sep="")
if (!any(agrep(outcomecall,colnames(data),ignore.case=TRUE))) {
stop('invalid outcome')
}
if (!any(data$State==statecall)) {
stop('invalid state')
}
##assign values for best and worst
if (num=="best") {
num<-1
}
#what to do for worst
##filter by state
statedata <- subset(data,State==statecall)
##determine which column corresponds to outcome of interest
outcomeindex <- min(agrep(outcomecall,colnames(data),ignore.case=TRUE))
##build answermatrix and then clean out NAs
answermatrix <- statedata[,c(2,outcomeindex)]
print(answermatrix)
answermatrix[,2] <- as.numeric(as.character(answermatrix[,2]))
gooddata <- complete.cases(answermatrix)
answermatrix <- answermatrix[gooddata,]
##find the hospital with the lowest score
print (sorted)
}
rankhospital("MD","heart attack","worst")
x<1:10
x<-1:10
dim(m)<-c(2,5)
dim(x)<-c(2,5)
order(x)
?data.table
?data.table
rankhospital <- function (statecall,outcomecall,num="best"){
##read in the data
path <- "C:\\Users\\Rich\\Documents\\Github\\FirstRepo\\outcome-of-care-measures.csv"
data <- read.csv(path,stringsAsFactors=FALSE,na.strings="Not Available+")
##check for valid calls
outcomecall <- paste(outcomecall,"+",sep="")
if (!any(agrep(outcomecall,colnames(data),ignore.case=TRUE))) {
stop('invalid outcome')
}
if (!any(data$State==statecall)) {
stop('invalid state')
}
##assign values for best and worst
if (num=="best") {
num<-1
}
#what to do for worst
##filter by state
statedata <- subset(data,State==statecall)
##determine which column corresponds to outcome of interest
outcomeindex <- min(agrep(outcomecall,colnames(data),ignore.case=TRUE))
##build answermatrix and then clean out NAs
answermatrix <- statedata[,c(2,outcomeindex)]
print(answermatrix)
answermatrix[,2] <- as.numeric(as.character(answermatrix[,2]))
gooddata <- complete.cases(answermatrix)
answermatrix <- answermatrix[gooddata,]
##find the hospital with the lowest score
r <- order(answermatrix$V2)
print(r)
}
rankhospital("MD","heart attack","worst")
rankhospital <- function (statecall,outcomecall,num="best"){
##read in the data
path <- "C:\\Users\\Rich\\Documents\\Github\\FirstRepo\\outcome-of-care-measures.csv"
data <- read.csv(path,stringsAsFactors=FALSE,na.strings="Not Available+")
##check for valid calls
outcomecall <- paste(outcomecall,"+",sep="")
if (!any(agrep(outcomecall,colnames(data),ignore.case=TRUE))) {
stop('invalid outcome')
}
if (!any(data$State==statecall)) {
stop('invalid state')
}
##assign values for best and worst
if (num=="best") {
num<-1
}
#what to do for worst
##filter by state
statedata <- subset(data,State==statecall)
##determine which column corresponds to outcome of interest
outcomeindex <- min(agrep(outcomecall,colnames(data),ignore.case=TRUE))
##build answermatrix and then clean out NAs
answermatrix <- statedata[,c(2,outcomeindex)]
print(answermatrix)
answermatrix[,2] <- as.numeric(as.character(answermatrix[,2]))
gooddata <- complete.cases(answermatrix)
answermatrix <- answermatrix[gooddata,]
##find the hospital with the lowest score
r <-vector(mode="numeric")
r <- order(answermatrix$V2)
print(r)
}
rankhospital("MD","heart attack","worst")
rankhospital <- function (statecall,outcomecall,num="best"){
##read in the data
path <- "C:\\Users\\Rich\\Documents\\Github\\FirstRepo\\outcome-of-care-measures.csv"
data <- read.csv(path,stringsAsFactors=FALSE,na.strings="Not Available+")
##check for valid calls
outcomecall <- paste(outcomecall,"+",sep="")
if (!any(agrep(outcomecall,colnames(data),ignore.case=TRUE))) {
stop('invalid outcome')
}
if (!any(data$State==statecall)) {
stop('invalid state')
}
##assign values for best and worst
if (num=="best") {
num<-1
}
#what to do for worst
##filter by state
statedata <- subset(data,State==statecall)
##determine which column corresponds to outcome of interest
outcomeindex <- min(agrep(outcomecall,colnames(data),ignore.case=TRUE))
##build answermatrix and then clean out NAs
answermatrix <- statedata[,c(2,outcomeindex)]
print(answermatrix)
answermatrix[,2] <- as.numeric(as.character(answermatrix[,2]))
gooddata <- complete.cases(answermatrix)
answermatrix <- answermatrix[gooddata,]
##find the hospital with the lowest score
r <- order(answermatrix[,2])
print(r)
}
rankhospital("MD","heart attack","worst")
rankhospital <- function (statecall,outcomecall,num="best"){
##read in the data
path <- "C:\\Users\\Rich\\Documents\\Github\\FirstRepo\\outcome-of-care-measures.csv"
data <- read.csv(path,stringsAsFactors=FALSE,na.strings="Not Available+")
##check for valid calls
outcomecall <- paste(outcomecall,"+",sep="")
if (!any(agrep(outcomecall,colnames(data),ignore.case=TRUE))) {
stop('invalid outcome')
}
if (!any(data$State==statecall)) {
stop('invalid state')
}
##assign values for best and worst
if (num=="best") {
num<-1
}
#what to do for worst
##filter by state
statedata <- subset(data,State==statecall)
##determine which column corresponds to outcome of interest
outcomeindex <- min(agrep(outcomecall,colnames(data),ignore.case=TRUE))
##build answermatrix and then clean out NAs
answermatrix <- statedata[,c(2,outcomeindex)]
print(answermatrix)
answermatrix[,2] <- as.numeric(as.character(answermatrix[,2]))
gooddata <- complete.cases(answermatrix)
answermatrix <- answermatrix[gooddata,]
##sort the hospitals
r <- order(answermatrix[,2])
sorted <- answermatrix[r,]
print(sorted)
}
rankhospital("MD","heart attack","worst")
rankhospital <- function (statecall,outcomecall,num="best"){
##read in the data
path <- "C:\\Users\\Rich\\Documents\\Github\\FirstRepo\\outcome-of-care-measures.csv"
data <- read.csv(path,stringsAsFactors=FALSE,na.strings="Not Available+")
##check for valid calls
outcomecall <- paste(outcomecall,"+",sep="")
if (!any(agrep(outcomecall,colnames(data),ignore.case=TRUE))) {
stop('invalid outcome')
}
if (!any(data$State==statecall)) {
stop('invalid state')
}
##assign values for best and worst
if (num=="best") {
num<-1
}
#what to do for worst
##filter by state
statedata <- subset(data,State==statecall)
##determine which column corresponds to outcome of interest
outcomeindex <- min(agrep(outcomecall,colnames(data),ignore.case=TRUE))
##build answermatrix and then clean out NAs
answermatrix <- statedata[,c(2,outcomeindex)]
print(answermatrix)
answermatrix[,2] <- as.numeric(as.character(answermatrix[,2]))
gooddata <- complete.cases(answermatrix)
answermatrix <- answermatrix[gooddata,]
##sort the hospitals
colnames(answermatrix) <- c("hospital", "score")
r <- order(answermatrix$score)
sorted <- answermatrix[r,]
print(sorted)
}
rankhospital("MD","heart attack","worst")
rankhospital <- function (statecall,outcomecall,num="best"){
##read in the data
path <- "C:\\Users\\Rich\\Documents\\Github\\FirstRepo\\outcome-of-care-measures.csv"
data <- read.csv(path,stringsAsFactors=FALSE,na.strings="Not Available+")
##check for valid calls
outcomecall <- paste(outcomecall,"+",sep="")
if (!any(agrep(outcomecall,colnames(data),ignore.case=TRUE))) {
stop('invalid outcome')
}
if (!any(data$State==statecall)) {
stop('invalid state')
}
##assign values for best and worst
if (num=="best") {
num<-1
}
#what to do for worst
##filter by state
statedata <- subset(data,State==statecall)
##determine which column corresponds to outcome of interest
outcomeindex <- min(agrep(outcomecall,colnames(data),ignore.case=TRUE))
##build answermatrix and then clean out NAs
answermatrix <- statedata[,c(2,outcomeindex)]
answermatrix[,2] <- as.numeric(as.character(answermatrix[,2]))
gooddata <- complete.cases(answermatrix)
answermatrix <- answermatrix[gooddata,]
##sort the hospitals
colnames(answermatrix) <- c("hospital", "score")
r <- order(answermatrix$score)
sorted <- answermatrix[r,]
print(sorted)
}
rankhospital("MD","heart attack","worst")
rankhospital <- function (statecall,outcomecall,num="best"){
##read in the data
path <- "C:\\Users\\Rich\\Documents\\Github\\FirstRepo\\outcome-of-care-measures.csv"
data <- read.csv(path,stringsAsFactors=FALSE,na.strings="Not Available+")
##check for valid calls
outcomecall <- paste(outcomecall,"+",sep="")
if (!any(agrep(outcomecall,colnames(data),ignore.case=TRUE))) {
stop('invalid outcome')
}
if (!any(data$State==statecall)) {
stop('invalid state')
}
##assign values for best and worst
if (num=="best") {
num<-1
}
#what to do for worst
##filter by state
statedata <- subset(data,State==statecall)
##determine which column corresponds to outcome of interest
outcomeindex <- min(agrep(outcomecall,colnames(data),ignore.case=TRUE))
##build answermatrix and then clean out NAs
answermatrix <- statedata[,c(2,outcomeindex)]
answermatrix[,2] <- as.numeric(as.character(answermatrix[,2]))
gooddata <- complete.cases(answermatrix)
answermatrix <- answermatrix[gooddata,]
##sort the hospitals
colnames(answermatrix) <- c("hospital", "score")
r <- order(answermatrix$score,answermatrix$hospital)
sorted <- answermatrix[r,]
print(sorted)
}
rankhospital("MD","heart attack","worst")
dim(x)
x
?dim
?numrows
?num.rows
nrow(x)
rankhospital <- function (statecall,outcomecall,num="best"){
##read in the data
path <- "C:\\Users\\Rich\\Documents\\Github\\FirstRepo\\outcome-of-care-measures.csv"
data <- read.csv(path,stringsAsFactors=FALSE,na.strings="Not Available+")
##check for valid calls
outcomecall <- paste(outcomecall,"+",sep="")
if (!any(agrep(outcomecall,colnames(data),ignore.case=TRUE))) {
stop('invalid outcome')
}
if (!any(data$State==statecall)) {
stop('invalid state')
}
##assign values for best
if (num=="best") {
num<-1
}
##assign value for worst after data is narrowed and sorted
##filter by state
statedata <- subset(data,State==statecall)
##determine which column corresponds to outcome of interest
outcomeindex <- min(agrep(outcomecall,colnames(data),ignore.case=TRUE))
##build answermatrix and then clean out NAs
answermatrix <- statedata[,c(2,outcomeindex)]
answermatrix[,2] <- as.numeric(as.character(answermatrix[,2]))
gooddata <- complete.cases(answermatrix)
answermatrix <- answermatrix[gooddata,]
##sort the hospitals
colnames(answermatrix) <- c("hospital", "score")
r <- order(answermatrix$score,answermatrix$hospital)
sorted <- answermatrix[r,]
##determine hospital selected in num
if (num=="worst") {
num<-nrow(sorted)
}
answer<-sorted[num,1]
}
rankhospital("MD","heart attack","worst")
rankhospital <- function (statecall,outcomecall,num="best"){
##read in the data
path <- "C:\\Users\\Rich\\Documents\\Github\\FirstRepo\\outcome-of-care-measures.csv"
data <- read.csv(path,stringsAsFactors=FALSE,na.strings="Not Available+")
##check for valid calls
outcomecall <- paste(outcomecall,"+",sep="")
if (!any(agrep(outcomecall,colnames(data),ignore.case=TRUE))) {
stop('invalid outcome')
}
if (!any(data$State==statecall)) {
stop('invalid state')
}
##assign values for best
if (num=="best") {
num<-1
}
##assign value for worst after data is narrowed and sorted
##filter by state
statedata <- subset(data,State==statecall)
##determine which column corresponds to outcome of interest
outcomeindex <- min(agrep(outcomecall,colnames(data),ignore.case=TRUE))
##build answermatrix and then clean out NAs
answermatrix <- statedata[,c(2,outcomeindex)]
answermatrix[,2] <- as.numeric(as.character(answermatrix[,2]))
gooddata <- complete.cases(answermatrix)
answermatrix <- answermatrix[gooddata,]
##sort the hospitals
colnames(answermatrix) <- c("hospital", "score")
r <- order(answermatrix$score,answermatrix$hospital)
sorted <- answermatrix[r,]
##determine hospital selected in num
if (num=="worst") {
num<-nrow(sorted)
}
answer<-sorted[num,1]
print(answer)
}
rankhospital("MD","heart attack","worst")
rankhospital("TX","heart failure",4)
rankhospital <- function (statecall,outcomecall,num="best"){
##read in the data
path <- "C:\\Users\\Rich\\Documents\\Github\\FirstRepo\\outcome-of-care-measures.csv"
data <- read.csv(path,stringsAsFactors=FALSE,na.strings="Not Available+")
##check for valid calls
outcomecall <- paste(outcomecall,"+",sep="")
if (!any(agrep(outcomecall,colnames(data),ignore.case=TRUE))) {
stop('invalid outcome')
}
if (!any(data$State==statecall)) {
stop('invalid state')
}
##assign values for best
if (num=="best") {
num<-1
}
##filter by state
statedata <- subset(data,State==statecall)
##determine which column corresponds to outcome of interest
outcomeindex <- min(agrep(outcomecall,colnames(data),ignore.case=TRUE))
##build answermatrix and then clean out NAs
answermatrix <- statedata[,c(2,outcomeindex)]
answermatrix[,2] <- as.numeric(as.character(answermatrix[,2]))
gooddata <- complete.cases(answermatrix)
answermatrix <- answermatrix[gooddata,]
##sort the hospitals
colnames(answermatrix) <- c("hospital", "score")
r <- order(answermatrix$score,answermatrix$hospital)
sorted <- answermatrix[r,]
##determine hospital selected in num
if (num=="worst") {
num<-nrow(sorted)
}
if (num>nrow(statedata)) {
answer="NA"
} else {
answer<-sorted[num,1]
}
print(answer)
}
rankhospital("MD","heart attack","worst")
rankhospital("TX","heart failure",4)
rankhospital("MN","heart attack",5000)
rankhospital <- function (statecall,outcomecall,num="best"){
##read in the data
path <- "C:\\Users\\Rich\\Documents\\Github\\FirstRepo\\outcome-of-care-measures.csv"
data <- read.csv(path,stringsAsFactors=FALSE,na.strings="Not Available+")
##check for valid calls
outcomecall <- paste(outcomecall,"+",sep="")
if (!any(agrep(outcomecall,colnames(data),ignore.case=TRUE))) {
stop('invalid outcome')
}
if (!any(data$State==statecall)) {
stop('invalid state')
}
##assign values for best
if (num=="best") {
num<-1
}
##filter by state
statedata <- subset(data,State==statecall)
##determine which column corresponds to outcome of interest
outcomeindex <- min(agrep(outcomecall,colnames(data),ignore.case=TRUE))
##build answermatrix and then clean out NAs
answermatrix <- statedata[,c(2,outcomeindex)]
answermatrix[,2] <- as.numeric(as.character(answermatrix[,2]))
gooddata <- complete.cases(answermatrix)
answermatrix <- answermatrix[gooddata,]
##sort the hospitals
colnames(answermatrix) <- c("hospital", "score")
r <- order(answermatrix$score,answermatrix$hospital)
sorted <- answermatrix[r,]
##determine hospital selected in num
if (num=="worst") {
num<-nrow(sorted)
}
if (num>nrow(statedata)) {
answer=NA
} else {
answer<-sorted[num,1]
}
print(answer)
}
rankhospital("MN","heart attack",5000)
setwd("~/GitHub/FirstRepo")
submit()
source('~/GitHub/FirstRepo/rprog-scripts-submitscript3.R')
submit()
submit()
submit()
submit()
?gl
View(x)
?%
path <- "C:\\Users\\Rich\\Documents\\Github\\FirstRepo\\outcome-of-care-measures.csv"
data <- read.csv(path,stringsAsFactors=FALSE,na.strings="Not Available+")
s<-split(data,data$State)
lapply(s,order(s))
lappy(s,order)
lapply(s,order)
z<-lapply(s,order)
z
